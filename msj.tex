\documentclass[sigconf]{acmart}
% \documentclass{...}
%\input{./def/yf-formatting}
\input{./def/yf-def}

%=================================
%Yufei's stuff
%\usepackage{amsmath}
\usepackage{balance}
%\usepackage{times}
\usepackage{microtype}

\def\vgap{\vspace{0mm}}
\def\extraspacing{\vspace{1mm} \noindent}
\def\figcapup{\vspace{-2mm}}
\def\figcapdown{\vspace{-4mm}}

\def\A{\mathcal{A}}
\def\B{\mathcal{B}}
\def\C{\mathcal{C}}
\def\E{\mathcal{E}}
\def\G{\mathcal{G}}
\def\I{\mathcal{I}}
\def\J{\mathcal{J}}
\def\II{\mathscr{I}}
\def\L{\mathcal{L}}
\def\P{\mathcal{P}}
\def\Q{\mathcal{Q}}
\def\R{\mathcal{R}}
\def\T{\mathcal{T}}
\def\U{\mathcal{U}}
\def\V{\mathcal{V}}
\def\X{\mathcal{X}}
\def\XX{\mathscr{X}}
\def\Y{\mathcal{Y}}
\def\YY{\mathscr{Y}}
\def\Z{\mathcal{Z}}

\def\out{\mathrm{OUT}}

\allowdisplaybreaks
%=================================

%====== from acm ======
\acmDOI{}
\acmISBN{}

\acmConference[]{...}{...}{...}
\acmYear{...}
\copyrightyear{}
\acmArticle{}
\acmPrice{}
%======================



\begin{document}
%\begin{sloppy}
    
\title{Optimal (Multiway) Spatial Joins}

% \author{}
% \affiliation{
% 	\institution{Chinese University of Hong Kong}
% 	\city{Hong Kong}
% 	\country{China}}	

\author{}


\begin{abstract}
    In a {\em spatial join}, we are given a constant number $k \geq 2$ of sets containing axis-parallel rectangles in a 2D space, denoted as $R_1, R_2, ..., R_k$. The objective is to identify and report all $k$-tuples $(r_1, r_2, ..., r_k) \in R_1 \times R_2 \times ... \times R_k$ where the rectangles $r_1, r_2, ..., r_k$ have a non-empty intersection, i.e., $r_1 \cap r_2 \cap ... \cap r_k \neq \emptyset$. This problem holds significant importance in spatial databases and has been extensively studied for over two decades. We explain how to settle the problem in $O(n \log n + \out)$ time using $O(n)$ space --- regardless of the constant $k$ --- where $n = \sum_{i=1}^k |R_i|$ and $\out$ is the result size (i.e., the total number of $k$-tuples reported). The time complexity is asymptotically optimal in the class of comparison-based algorithms, to which our solution belongs. Our result significantly improves the state of the art, which is an algorithm with running time $O(n \log^{\Theta(k)} n + \out)$.
\end{abstract}

\maketitle 

\section{Introduction} \label{sec:intro}

This paper revisits the {\em spatial join} (SJ) problem defined as follows. Let $k$ be a constant integer at least 2. In the {\em $k$-SJ} problem, the input comprises $k$ sets --- denoted as $R_1, R_2, ..., R_k$ --- of axis-parallel rectangles\footnote{A rectangle $r$ in 2D space is {\em axis-parallel} if it has the form $r = [x_1, x_2] \times [y_1, y_2]$.} in $\real^2$. The goal is to find all $k$-tuples $(r_1, r_2, ..., r_k)$ where
\myitems{
    \item $r_i \in R_i$ for each $i \in [1, k]$; and
    \item $r_1 \cap r_2 \cap ... \cap r_k \neq \emptyset$, namely, the $k$ rectangles $r_1, r_2, ..., r_k$ have a non-empty intersection.
}
We represent the set of these $k$-tuples as $\J_k(R_1, R_2, ..., R_k)$, referred to as the {\em join result}. Set $n = \sum_{i=1}^k |R_i|$, i.e., the input size, and $\out = |\J_k(R_1, R_2, ..., R_k)|$, i.e., the output size.

\vgap

SJ is a fundamental operation in spatial databases, which manage geometric entities such as land parcels, service areas, habitat zones, commercial districts, administrative boundaries, etc. It plays a crucial role in implementing the {\em filter-refinement mechanism}, the dominant approach in spatial databases for computing the overlays of different entities. Specifically, a geometric entity, at the lowest level, is usually modeled as a polygon. Determining whether two entities overlap amounts to deciding if two polygons intersect, which can be very expensive when the polygons have complex boundaries. For better efficiency, a spatial database stores the {\em minimum bounding rectangle} (MBR) of each polygon $\P$, which is the smallest axis-parallel rectangle enclosing $\P$. Two polygons $\P_1$ and $\P_2$ can overlap with each other only if their MBRs $r_1$ and $r_2$ have a non-empty intersection. To overlay $k$ different sets of entities, filter-refinement first performs ``filtering'' by using an SJ to fetch all $k$-tuples $(r_1, r_2, ..., r_k)$ where each $r_i$ ($1 \le i \le k$) is the MBR of a polygon $\P_i$ and a ``refines'' every such $k$-tuple by checking if $\P_1, \P_2, ..., \P_k$ indeed have a non-empty intersection.

\subsection{Previous Results} \label{sec:intro:prev}

SJs have been extensively studied in the database system , which has led to the development of numerous interesting methods that, although lacking strong theoretical guarantees, demonstrate excellent empirical performance on real-world applications. We refer the interested readers to \cite{mp01,???} as entry points into the literature.

\vgap



\bibliographystyle{plainurl}% the mandatory bibstyle
\bibliography{ref}

\balance

%\end{sloppy}
\end{document}

